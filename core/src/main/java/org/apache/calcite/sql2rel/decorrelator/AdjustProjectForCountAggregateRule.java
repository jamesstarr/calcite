/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.calcite.sql2rel.decorrelator;

import org.apache.calcite.plan.RelOptRuleCall;
import org.apache.calcite.plan.RelRule;
import org.apache.calcite.rel.RelNode;
import org.apache.calcite.rel.core.Aggregate;
import org.apache.calcite.rel.core.AggregateCall;
import org.apache.calcite.rel.core.Correlate;
import org.apache.calcite.rel.core.JoinRelType;
import org.apache.calcite.rel.core.Project;
import org.apache.calcite.rel.type.RelDataTypeField;
import org.apache.calcite.rex.RexBuilder;
import org.apache.calcite.rex.RexInputRef;
import org.apache.calcite.rex.RexNode;
import org.apache.calcite.sql.fun.SqlCountAggFunction;
import org.apache.calcite.tools.RelBuilder;
import org.apache.calcite.tools.RelBuilderFactory;
import org.apache.calcite.util.ImmutableBeans;
import org.apache.calcite.util.Pair;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static java.util.Objects.requireNonNull;

/**
 * Planner rule that adjusts projects when counts are added.
 */
public final class AdjustProjectForCountAggregateRule
    extends RelRule<AdjustProjectForCountAggregateRule.Config> {
  final RelDecorrelator d;

  static Config config(boolean flavor, RelDecorrelator decorrelator,
      RelBuilderFactory relBuilderFactory) {
    return Config.EMPTY.withRelBuilderFactory(relBuilderFactory)
        .withOperandSupplier(b0 ->
            b0.operand(Correlate.class).inputs(
                b1 -> b1.operand(RelNode.class).anyInputs(),
                b2 -> flavor
                    ? b2.operand(Project.class).oneInput(b3 ->
                    b3.operand(Aggregate.class).anyInputs())
                    : b2.operand(Aggregate.class).anyInputs()))
        .as(Config.class)
        .withFlavor(flavor)
        .withDecorrelator(decorrelator)
        .as(Config.class);
  }

  /**
   * Creates an AdjustProjectForCountAggregateRule.
   */
  AdjustProjectForCountAggregateRule(Config config) {
    super(config);
    this.d = requireNonNull(config.decorrelator());
  }

  @Override public void onMatch(RelOptRuleCall call) {
    final Correlate correlate = call.rel(0);
    final RelNode left = call.rel(1);
    final Project aggOutputProject;
    final Aggregate aggregate;
    if (config.flavor()) {
      aggOutputProject = call.rel(2);
      aggregate = call.rel(3);
    } else {
      aggregate = call.rel(2);

      // Create identity projection
      final List<Pair<RexNode, String>> projects = new ArrayList<>();
      final List<RelDataTypeField> fields =
          aggregate.getRowType().getFieldList();
      for (int i = 0; i < fields.size(); i++) {
        projects.add(RexInputRef.of2(projects.size(), fields));
      }
      final RelBuilder relBuilder = call.builder();
      relBuilder.push(aggregate)
          .projectNamed(Pair.left(projects), Pair.right(projects), true);
      aggOutputProject = (Project) relBuilder.build();
    }
    onMatch2(call, correlate, left, aggOutputProject, aggregate);
  }

  private void onMatch2(
      RelOptRuleCall call,
      Correlate correlate,
      RelNode leftInput,
      Project aggOutputProject,
      Aggregate aggregate) {
    if (d.generatedCorRels.contains(correlate)) {
      // This Correlate was generated by a previous invocation of
      // this rule. No further work to do.
      return;
    }

    d.setCurrent(call.getPlanner().getRoot(), correlate);

    // check for this pattern
    // The pattern matching could be simplified if rules can be applied
    // during decorrelation,
    //
    // CorrelateRel(left correlation, condition = true)
    //   leftInput
    //   Project-A (a RexNode)
    //     Aggregate (groupby (0), agg0(), agg1()...)

    // check aggOutputProj projects only one expression
    List<RexNode> aggOutputProjExprs = aggOutputProject.getProjects();
    if (aggOutputProjExprs.size() != 1) {
      return;
    }

    JoinRelType joinType = correlate.getJoinType();
    // corRel.getCondition was here, however Correlate was updated so it
    // never includes a join condition. The code was not modified for brevity.
    RexNode joinCond = d.relBuilder.literal(true);
    if ((joinType != JoinRelType.LEFT)
        || (joinCond != d.relBuilder.literal(true))) {
      return;
    }

    // check that the agg is on the entire input
    if (!aggregate.getGroupSet().isEmpty()) {
      return;
    }

    List<AggregateCall> aggCalls = aggregate.getAggCallList();
    Set<Integer> isCount = new HashSet<>();

    // remember the count() positions
    int i = -1;
    for (AggregateCall aggCall : aggCalls) {
      ++i;
      if (aggCall.getAggregation() instanceof SqlCountAggFunction) {
        isCount.add(i);
      }
    }

    // now rewrite the plan to
    //
    // Project-A' (all LHS plus transformed original projections,
    //             replacing references to count() with case statement)
    //   Correlate(left correlation, condition = true)
    //     leftInput
    //     Aggregate(groupby (0), agg0(), agg1()...)
    //
    final RexBuilder rexBuilder = d.relBuilder.getRexBuilder();
    List<RexNode> requiredNodes =
        correlate.getRequiredColumns().asList().stream()
            .map(ord -> rexBuilder.makeInputRef(correlate, ord))
            .collect(Collectors.toList());
    Correlate newCorrelate = (Correlate) d.relBuilder.push(leftInput)
        .push(aggregate).correlate(correlate.getJoinType(),
            correlate.getCorrelationId(),
            requiredNodes).build();


    // remember this rel so we don't fire rule on it again
    // REVIEW jhyde 29-Oct-2007: rules should not save state; rule
    // should recognize patterns where it does or does not need to do
    // work
    d.generatedCorRels.add(newCorrelate);

    // need to update the mapCorToCorRel Update the output position
    // for the corVars: only pass on the corVars that are not used in
    // the join key.
    if (d.cm.mapCorToCorRel.get(correlate.getCorrelationId()) == correlate) {
      d.cm.mapCorToCorRel.put(correlate.getCorrelationId(), newCorrelate);
    }

    RelNode newOutput =
        d.aggregateCorrelatorOutput(newCorrelate, aggOutputProject, isCount);

    call.transformTo(newOutput);
  }

  /**
   * Rule configuration.
   */
  public interface Config extends RelDecorrelator.Config {
    @Override default AdjustProjectForCountAggregateRule toRule() {
      return new AdjustProjectForCountAggregateRule(this);
    }

    /**
     * Returns the flavor of the rule (true for 4 operands, false for 3
     * operands).
     */
    @ImmutableBeans.Property
    boolean flavor();

    /**
     * Sets {@link #flavor}.
     */
    Config withFlavor(boolean flavor);
  }
}
